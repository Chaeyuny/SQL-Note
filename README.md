# SQL-Note
업무하면서 알게 된 DB 지식 정리(Oracle) 


- 일하면서 바탕화면 메모지에 적어두고 활용했던 SQL 관련 지식
- 에러 발생 시 스마트폰으로 검색해서 해결했던 내용 포함
- 메모 내용 + 추가로 찾아보며 공부한 내용 정리
- 인터넷망 사용 금지, 데이터 유출 금지인 보안환경이라 실제 사용했던 쿼리는 첨부 불가능

<br>
<br>

<h3>📌 힌트(hint) 사용 : 쿼리튜닝 </h3> <br>
✔ 업무에서 가장 많이 활용되고 있었던 건 /*+parallel(4)*/, 때때로 /*+ordered use_nl(a b c)*/
<br><br>

✅ /*+parallel(4)*/

: 검색해서 나오는 건 정확히는 /*+ PARALLEL(table_name, degree)*/ . 실제로 쓸때는 그냥 숫자만 기재해서 활용했다. select 바로 옆에 붙여서 실행하면 적용된다.



    select /*+parallel(4)*/ from table_name;

      

- 쉽게 말해 병렬처리문인데, 숫자는 degree를 의미한다. 
- 참고한 사이트 설명상으로는 '하나의 operation 수행에 대한 serever process 개수'라고 기재되어있고, degree에 영향을 주는 요인들도 다양하다. 
- 나는 힌트 이름이 병렬처리이니 쉽게 말해 한사람이 할 작업을 넷이서 하게끔 속도를 높여주는 것이라고 이해했다. (쿼리문에 따라 속도가 무조건 높아지진 않는다) 
단,숫자를 너무 높이면 서버에 과부하를 줄 수 있으니 주의해야 한다. 
      
  <br>
  <br>
  <br>
  
✅   /*+ordered use_nl(a b c)*/

: a b c는 테이블 alias 명이다. 
- /*+ordered*/는 from절 테이블 순서대로 조인하도록 하는 힌트(접근 순서 결정)
      
- /*+use_nl*/은  접근 방법을 결정하는 힌트절인데 NESTED LOOP JOIN 방식으로 조인하도록 유도한다. NESTED LOOP JOIN은 중첩 루프조인으로, 자바에서 중첩 FOR문 사용할때랑 동작방식이 비슷하다. 
- 업무에서는 두 힌트를 같이 썼다. 찾아보니 USE_NL은 단독으로 사용하기도 하지만 업무에서처럼 OREDRED와 같이 조인순서를 지정하는 힌트와 함께 사용하는 것이 일반적이라고 한다. 
      
 

  <br>
  <br>
  
 ✅  /*+ LEADING (b, a, c)*/ 
 
     : ordered 힌트절에 대해 찾다가 알게 된 힌트다. 
- ordered가 from절에 기재된 순서대로 조인하기 때문에 프롬절에 종속적이라면. 해당 힌트는 그렇지 않다. 
- from에 기술된 테이블 순서와 관계없이 힌트에 직접 조인순서를 기술할 수 있기 때문이었다.
     
    

<br><br><br>  

<h4>💡 comment</h4>

- 나는 업무 시 힌트가 있을 때와 없을 때 속도차이를 비교하며 사용했다. 추출 업무가 굉장히 많아서 결과물이 얼마나 빨리 나오느냐에 중점을 둘 수 밖에 없었기 때문이었다.

- 시간을 최소화하기위해 rownum을 걸어 샘플 데이터만 나오도록 해서 테스트해보았는데, 패럴을 넣을 때와 넣지 않을 때, ordered를 사용할때와 사용하지 않을 때 등등 어떤 경우가 가장 데이터가 빨리 나오는지를 테스트한 후에야 본격적으로 추출을 시작했다. 

- 항상 쿼리를 짜고 rownum 을 걸어 테스트해보는 과정을 좋아했다. 힌트 쓴다고 무작정 빨라지는것은 아니었기 때문이다. 결과물 확인한답시고 쿼리 전체를 몇 시간씩 돌리다가 에러가 나면 상당한 시간을 낭비하게 됐고, 그러지 않으려고 쓰기 시작한 방법이었다.

- 쿼리에 따라 다르긴 하지만 낱개로 샘플로 돌려보면 이 쿼리문이 제대로 동작하는지부터 확인할 수 있었다. 샘플로 나온 정보가 맞는지 시스템 화면과 비교해볼 수 있기도 하고, 샘플이 나오는 속도가 너무 오래걸리면 쿼리에 문제가 있는 경우가 대부분이었으므로 rownum 걸어서 확인하면 빠르게 수정할 수 있었다. 
<br>

<h4>✔ CPU COST</h4>

- Plan을 확인하면 cpu 점유율을 확인할 수 있다. 플랜에 대해 상세하게 알지는 못했지만, cpu cost만 비교해봐도 추출 성능을 높이는 데에는 큰 도움이 되었다. 
- 힌트가 무조건 빠른 게 아니라는 것을 알 수 있었던 것도 플랜을 통해 코스트를 비교해봤기 때문이었다. 예전 쿼리들에 무분별하게 패럴이 들어있는 경우 꼭 테스트를 거쳐 힌트가 없을 때와 속도비교를 해서 작업했다.
- 의외의 기능도 있다. 조인이 잘못된 경우에도 이 코스트 숫자를 통해 확인할 수 있었다. 습관처럼 플랜을 켰는데 코스트 숫자가 비정상적으로 커서 확인해보면 테이블 조인조건이 빠져있는 경우가 많았다.

    
 <br> <br>

*참고사이트
- https://devuna.tistory.com/35 
- https://koeiking11.tistory.com/entry/%EC%98%A4%EB%9D%BC%ED%81%B4-%ED%9E%8C%ED%8A%B8-ordered-usenl 
- https://exmemory.tistory.com/44








<br><br><br><br>

<h3>📌 서브쿼리 </h3> <br>
✔ 가져올 컬럼들이 몇십개여서 (최소 20개 이상이 대부분) 서브쿼리를 많이 사용했다. 특히 각 컬럼마다 테이블이 많이 다를 경우가 상당수라 select절에 쓰는 스칼라 서브쿼리를 활용할 일이 많았다. <br><br>

✅ 서브쿼리 내에서 메인쿼리 컬럼을 모두 사용할 수 있다. 단, 메인쿼리에선 서브쿼리 컬럼을 사용할 수 없다 
    
- 추출조건을 주로 메인쿼리에 걸기 때문에, 메인쿼리에 있는 테이블 키를 서브쿼리 컬럼값의 테이블 키와 조인하는 방식을 많이 사용했다. 
    
- 연관 서브쿼리에 해당한다. 
    
  <br>
  <br>
  <br>  
    
✅ 집계함수를 써야하는데, 메인 select 절에 서브쿼리가 포함되어 있다면 ?

       : 조건으로 들어가는 메인테이블의 컬럼이 group by 항목으로 들어가야 한다. 


- 이것 때문에 에러를 본 적이 있다. 서브쿼리를 통째로 넣어보기도 하고 서브쿼리에서 가져오는 컬럼을 넣어보기도 했는데, 
    위에서 말했다시피 메인쿼리는 서브쿼리 컬럼을 사용할 수 없어서 에러가 나기는 매한가지였다. 
    
- 연관 서브쿼리 조건으로 들어간 메인쿼리 컬럼이 group by로 들어가니 해결되었다. 


<br><br><br>  

<h4>💡 comment</h4>

- 서브쿼리를 자주 사용하긴 했지만 항상 신중하게 사용해야 했다. 특히 스칼라 서브쿼리의 경우 '단일 행 오류'를 정말 많이 만났다. <br>
기준이 되는 키값 하나에 엮인 컬럼값이 두 개 이상인 경우 나는 오류였다. 

- 이런 상황에서는 기준 키값인 고객번호 하나만 서브쿼리에 사용한 select 절에 넣어 조회해보고, 어떤 컬럼 때문에 값이 두개 나오게 됐는지를 파악했다. 데이터 특성 상 주 원인은 날짜나 접수번호 같은 것들이었고 요청자료 기준에 맞는 조건을 서브쿼리에 추가해주면 행 하나만 나오게 수정할 수 있었다. 

- 애매하거나 랜덤으로 뽑아도 되는 조건의 경우 조건을 따로 추가하지 않고, 스칼라 서브쿼리 컬럼값에 MAX나 MIN 함수를 걸어 행이 하나만 나오도록 조치했다. 

- 단일 행 오류의 원인이 날짜인 경우는 가장 최근 값을 가져오도록 하거나, 쿼리 기준 날짜에 맞춰지도록 조건을 추가하면 해결할 수 있었다. 하지만 접수번호와 같이 날짜보다는 모호한 값인 경우 요청자와 협의가 필요했다. 접수이력을 다 보고싶다고 하면 해당 값은 서브쿼리를 쓰지 않고 직접 조인해서 키값 당 모든 접수번호가 보이도록 수정했고, 최근 값 하나만 있어도 된다고 하는 경우 MAX를 걸어 해결할 수 있었다. 

- 일부만 예시를 들긴 했지만 이런 조건 하나하나마다 요청자별로, 각 쿼리별로 항상 원하는 값이 달라졌기 때문에 항상 테이블을 파고들어 확인하는 과정이 필요했다.



  <br> <br>

*참고사이트
- https://kjh-alltag.tistory.com/53   







<br><br><br><br>
 <h3>📌 아우터 조인 </h3> <br>
 ✔ 대상 고객번호를 요청자쪽에서 미리 주거나, 조건을 정해주면 대상을 추려서 추출할 일이 많았다. 기준조건이 있으니 임시테이블을 생성해 이를 기준으로 아우터 조인을 걸어서 원하는 값을 가져오는 방식을 자주 사용하게 됐다.<br><br>
 
 ✅ Outer Join (외부조인)
 - 조인조건을 만족하지 못하는 행들을 보기 위해 사용된다. 기준 테이블의 컬럼값들을 누락 없이 모두 보여준다. 
  
  <br><br>
  
  
 ✅ 오라클에서의 조인 
        : (+) 기호 사용
- 두 테이블 사이에서 교집합이 아닌, 즉 조인조건을 만족하지 않는 행까지 값을 가져올 수 있다. (+)기호를 걸지 않은 쪽 테이블이 기준 테이블이 된다. 
- WHERE A.ID = B.ID (+) 와 같은 조인조건이 걸려있는 경우, A테이블의 모든 ID가 출력되고, B테이블은 A테이블 조인조건(ID)를 만족하는 경우 값이 출력되고, 만족하지 않으면 NULL이 출력된다. 

  <br><br>

 ✅ where절에 집합함수 있을 때 (+) 연산자 걸기 
 - a테이블 기준으로 b테이블을 아우터 조인하려고 할 때, WHERE NVL(A.DATA,0) = NVL(B.DATA,0) 라는 조건이 포함되어 있는 경우 연산자 거는 방식이 달랐다. 
 -  WHERE NVL(A.DATA,0) = NVL(B.DATA,0) (+)   --> 에러 발생
 -  WHERE NVL(A.DATA,0) = NVL(B.DATA(+),0)    --> 정상 작동, 함수를 사용할 경우 연산자는 함수 내 컬럼값 옆에 붙여야 한다.


  <br> <br>


<h4>💡 comment</h4>

- 아우터는 항상 헷갈리는 부분이었다. 추출 항목이 많았으므로 어떤 테이블을 기준으로 해야할지도 결정해야 했고, 테이블 갯수가 많은 경우 조건에 따라 일부만 아우터를 걸어야 하는 경우도 있어서 이러한 부분을 두고 동료와 많이 논의했었다. 
- 주로 LEFT 조인만 사용했고, 익숙해지지 않았을 당시에는 이론적인 내용을 알고있었는데도 (+) 연산자 거는 방향이 헷갈려서 다시 검색해보곤 했다. 
- 오라클에서만 (+)를 쓸 수 있다고 해서, 잊어버리지 않으려고 종종 LEFT JOIN ON 구문을 직접 써서 조인하는 방법도 사용했다. 


*참고사이트
- https://m.blog.naver.com/yysvip/220132590942
- https://titanic1997.tistory.com/50
    
    
    
    
<br><br><br><br>    
    
<h3>📌 로우를 컬럼으로 변경하기 </h3> <br>
✔ 추출 작업 특성 상 행으로 출력되는 항목들을 열로 변경해야 하는 경우 사용했던 방법들이다
<br><br>

✅ DECODE 함수

     : DECODE(컬럼, 조건, 결과)  --해당 컬럼의 조건이 참이면 결과를 출력한다 

<br>

- IF ELSE문과 비슷하게 동작하는 함수이고, 조건과 결과는 늘릴 수 있다. (늘어날 경우 ELSE IF문처럼 동작한다)
- 추출요청이 오는 데이터들 중 가장 많았던 형식은, 고객 정보를 월별로 추출해달라는 것이었다.
- 실제 테이블에 들어있는 건 아래와 같은 형식이었다. <br>

![image](https://github.com/Chaeyuny/SQL-Note/assets/103619605/eef34d28-6a19-42c4-8278-b6a637069ab5)

<br>

- 하지만 요청 양식은 대부분 다음과 같았다.<br>

![image](https://github.com/Chaeyuny/SQL-Note/assets/103619605/b8dac3ad-e148-4874-8490-a199a3af2cad)


- 그래서 디코드문을 통해 날짜 행 데이터를 컬럼 형식으로 바꿔야 했다.
- 실제로 한 고객에 들어있는 요금년월은 매우 많았기 때문에 아래와 같이 WHERE 절에서 추출하려는 특정 년월을 설정해주어야 했다. 
- 특정 년월이 연속되지 않은 경우에는 IN으로 조건을 걸어줄 수도 있다. 

<br>


       SELECT NUM                             "고객번호"
           ,DECODE(BILLYM,'201802',MNY)    "2018.02 요금"
           ,DECODE(BILLYM,'201803',MNY)    "2018.03 요금"
           ,DECODE(BILLYM,'201804',MNY)    "2018.04 요금"
       FROM MNY_TABLE
       WHERE BILLYM BETWEEN '201802' AND '201804';
<br>

<br><br>
☑ DECODE 문 ORDER BY 절에서 활용하기 

- 보통 양식 항목은 컬럼만 적혀있기 때문에, 정렬은 ORDER BY를 사용해 결과물을 보기좋게 만들어서 보낸다.
- 하지만 요청자가 특정 컬럼 값만 원하는 경우, 순차정렬이 아닌 양식에 기재된 순서대로 맞춰야 하는 경우가 있다
- 상품의 종류가 A부터 Z까지 있을 때, 요청자는 C부터 F까지만 원하고 양식에 기재된 순서도 알파벳순이 아니라 E F D C 처럼 요청자가 원하는 순서가 정해진 경우가 있는 것이다.  
- 이럴 때 디코드문을 ORDER BY에서 사용하면 원하는 순서대로 정렬이 가능하다. 


       SELECT NUM                             "고객번호"
           ,PRD_CLASS                         "상품종류"
           ,PRD_MNY                           "상품가격"

       FROM PRD_TABLE
       WHERE PRD_CLASS IN ('C', 'D', 'E', 'F')
       ORDER BY DECODE(PRO_CLASS, 'E', 1
                                  'F', 2
                                  'D', 3
                                  'C', 4), NUM;

- 이렇게 쓰면 상품종류가 C,D,E,F인 고객들을 출력하는데, 순서를 PRO_CLASS(상품종류)가 E이면 첫번째로, F면 두번째로, 'D' 면 세번째로, 'C'면 4번째로 정렬 후 고객번호순으로 결과물이 나오게 된다. 

<br><br>
☑ CASE문

     : CASE WHEN 조건 THEN 리턴값(조건 참) ELSE 리턴값(조건 이외) END   --WHEN, THEN으로 조건 및 결과 추가 가능
     
- 행을 열로 바꿀 때 사용했다기보다, DECODE문보다 복잡한 조건을 써야 할 때 유용하게 사용했던 조건이다
- DECODE와 마찬가지로 WHEN, THEN, ELSE 구문에 따라 IF ELSE문과 같이 동작한다. 
- ELSE는 생략이 가능하고, 만족 조건이 없는 경우 NULL을 리턴한다. 
- 나는 주로 SELECT 절에서 활용했는데, 위의 DECODE 예시와 같이 사용하는 경우도 있었지만 아래와 같이 값 범위가 존재하는 데이터 구간을 나눌 때 사용했다.<br>

![image](https://github.com/Chaeyuny/SQL-Note/assets/103619605/9c6adbb4-84d3-4905-9440-9ebf09065570)

<br>

- 예시로, 1부터 20까지의 데이터를 5 단위로 나눈다고 하면 내가 알아보기 쉽게 구간을 끝값으로 설정할 때 사용한 것이다 

<br>


       SELECT NUM                                          "고객번호"
           ,CASE WHEN USAGE BETWEEN 1 AND 5 THEN '5' 
                 WHEN USAGE BETWEEN 6 AND 10 THEN '10' 
                 WHEN USAGE BETWEEN 11 AND 15 THEN '15' 
                 WHEN USAGE BETWEEN 16 AND 20 THEN '20'
                 END                                      "구간"
              

       FROM USG_TABLE;
       
  <br>     
  
 ![image](https://github.com/Chaeyuny/SQL-Note/assets/103619605/76df257b-2f93-43a2-a887-f7a0082fb3ab)
 
 - 물론 실제 데이터에서는 대용량이다 보니 잘못된 값도 있거나 NULL이 들어가 있는 등의 경우가 존재했기 때문에 ELSE문을 이용해 구간 하나로 묶는 일이 많았다. 
 

<br><br>

✅ PIVOT

✔ 기존에 로우를 컬럼으로 바꾸기 위해 썼던 DECODE 대신 좀더 직관적으로 사용할 수 있다. <br>
✔ 다만 처음 쓰는 나에게는 살짝 까다로운 부분이 있다고 느껴졌다.
<br>


       SELECT *
         FROM ( 피벗 대상 쿼리문 )
       PIVOT ( 그룹합수(집계컬럼) FOR 피벗컬럼 IN (피벗컬럼값 AS 별칭 ... )


<br>

- 내가 사용한 쿼리에는 WHERE절이 존재해서 더 쓰기 어려웠는지도 모른다. 
- 방법을 이리저리 생각해보다가 서브쿼리 형태로 한번 더 덧씌워서 피벗을 사용했다. 
- 추출해야하는 결과물 형태는 다음과 같았다 <br>
- 부모 고객에 속해있는 자식 고객들의 총 호수, 그리고 이 자식 고객들의 유형별 호수를 구해야 했고 유형은 각 고객마다 값으로 부여되어 있었는데, 이부분이 컬럼으로 들어가야 했다. 

<br>

![image](https://github.com/Chaeyuny/SQL-Note/assets/103619605/4017373b-ac3e-4bee-aa72-1b0b18a35079)

<br><br>

       SELECT *
       FROM (
              SELECT T.SEQ  
                 ,T.NUM_C          NUM_P
                 ,B.CLASS_ALPH   CLASS_ALPH 
                 ,B.NUM_C          NUM_C

              FROM TMP_TABLE T
                  ,PARENTS A
                  ,CHILD B

              WHERE 1=1
                AND T.NUM_C     = A.NUM_P           (+)
                AND A.NUM_C     = B.NUM_C          (+)
              )

       PIVOT (
              COUNT(NUM_C) FOR CLASS_ALPH IN ('A', 'B', 'C', 'D', 'E')
       )

  <br> <br>
  




<h4>💡 comment</h4>

- 데이터가 나오는 형태를 고려해서 피벗을 사용해야 했다. 엑셀에서 피벗을 쓸 수 있긴 하지만 엑셀에서 나오는 피벗 데이터는 뭔가 너저분하고 알아보기 어려워서 쿼리 내에서 피벗 사용을 시도해봤다. 
- 디코드나 케이스가 많이 익숙해져서 피벗보다 편하긴 했지만, 피벗을 써보니까 쿼리 자체가 간결해보이고 데이터도 엑셀과 달리 깔끔하게 나온다는 점이 좋았다.
    
    
    
*참고사이트
- https://gent.tistory.com/42
    
    
