# SQL-Note
업무하면서 알게 된 DB 지식 정리(Oracle) 


- 일하면서 바탕화면 메모지에 적어두고 활용했던 SQL 관련 지식
- 에러 발생 시 검색해서 해결했던 내용 포함
- 메모 내용 + 추가로 찾아보며 공부한 내용 정리

<br>
<br>

<h3>📌 힌트(hint) 사용 : 쿼리튜닝 </h3> <br>
✔ 업무에서 가장 많이 활용되고 있었던 건 /*+parallel(4)*/, 때때로 /*+ordered use_nl(a b c)*/
<br><br>

✅ /*+parallel(4)*/

: 검색해서 나오는 건 정확히는 /*+ PARALLEL(table_name, degree)*/ . 실제로 쓸때는 그냥 숫자만 기재해서 활용했다. select 바로 옆에 붙여서 실행하면 적용된다.



    select /*+parallel(4)*/ from table_name;

      

- 쉽게 말해 병렬처리문인데, 숫자는 degree를 의미한다. 
- 참고한 사이트 설명상으로는 '하나의 operation 수행에 대한 serever process 개수'라고 기재되어있고, degree에 영향을 주는 요인들도 다양하다. 
- 나는 힌트 이름이 병렬처리이니 쉽게 말해 한사람이 할 작업을 넷이서 하게끔 속도를 높여주는 것이라고 이해했다. (쿼리문에 따라 속도가 무조건 높아지진 않는다) 
단,숫자를 너무 높이면 서버에 과부하를 줄 수 있으니 주의해야 한다. 
      
  <br>
  <br>
  <br>
  
✅   /*+ordered use_nl(a b c)*/

: a b c는 테이블 alias 명이다. 
- /*+ordered*/는 from절 테이블 순서대로 조인하도록 하는 힌트(접근 순서 결정)
      
- /*+use_nl*/은  접근 방법을 결정하는 힌트절인데 NESTED LOOP JOIN 방식으로 조인하도록 유도한다. NESTED LOOP JOIN은 중첩 루프조인으로, 자바에서 중첩 FOR문 사용할때랑 동작방식이 비슷하다. 
- 업무에서는 두 힌트를 같이 썼다. 찾아보니 USE_NL은 단독으로 사용하기도 하지만 업무에서처럼 OREDRED와 같이 조인순서를 지정하는 힌트와 함께 사용하는 것이 일반적이라고 한다. 
      
 

  <br>
  <br>
  
 ✅  /*+ LEADING (b, a, c)*/ 
 
     : ordered 힌트절에 대해 찾다가 알게 된 힌트다. 
- ordered가 from절에 기재된 순서대로 조인하기 때문에 프롬절에 종속적이라면. 해당 힌트는 그렇지 않다. 
- from에 기술된 테이블 순서와 관계없이 힌트에 직접 조인순서를 기술할 수 있기 때문이었다.
     
    

<br><br><br>  

<h4>💡 comment</h4>

- 나는 업무 시 힌트가 있을 때와 없을 때 속도차이를 비교하며 사용했다. 추출 업무가 굉장히 많아서 결과물이 얼마나 빨리 나오느냐에 중점을 둘 수 밖에 없었기 때문이었다.

- 시간을 최소화하기위해 rownum을 걸어 샘플 데이터만 나오도록 해서 테스트해보았는데, 패럴을 넣을 때와 넣지 않을 때, ordered를 사용할때와 사용하지 않을 때 등등 어떤 경우가 가장 데이터가 빨리 나오는지를 테스트한 후에야 본격적으로 추출을 시작했다. 

- 항상 쿼리를 짜고 rownum 을 걸어 테스트해보는 과정을 좋아했다. 힌트 쓴다고 무작정 빨라지는것은 아니었기 때문이다. 결과물 확인한답시고 쿼리 전체를 몇 시간씩 돌리다가 에러가 나면 상당한 시간을 낭비하게 됐고, 그러지 않으려고 쓰기 시작한 방법이었다.

- 쿼리에 따라 다르긴 하지만 낱개로 샘플로 돌려보면 이 쿼리문이 제대로 동작하는지부터 확인할 수 있었다. 샘플로 나온 정보가 맞는지 시스템 화면과 비교해볼 수 있기도 하고, 샘플이 나오는 속도가 너무 오래걸리면 쿼리에 문제가 있는 경우가 대부분이었으므로 rownum 걸어서 확인하면 빠르게 수정할 수 있었다. 
    
 <br> <br>

*참고사이트
- https://devuna.tistory.com/35 
- https://koeiking11.tistory.com/entry/%EC%98%A4%EB%9D%BC%ED%81%B4-%ED%9E%8C%ED%8A%B8-ordered-usenl 
- https://exmemory.tistory.com/44








<br><br><br><br>

<h3>📌 서브쿼리 </h3> <br>
✔ 가져올 컬럼들이 몇십개여서 (최소 20개 이상이 대부분) 서브쿼리를 많이 사용했다. 특히 각 컬럼마다 테이블이 많이 다를 경우가 상당수라 select절에 쓰는 스칼라 서브쿼리를 활용할 일이 많았다. <br><br>

✅ 서브쿼리 내에서 메인쿼리 컬럼을 모두 사용할 수 있다. 단, 메인쿼리에선 서브쿼리 컬럼을 사용할 수 없다 
    
- 추출조건을 주로 메인쿼리에 걸기 때문에, 메인쿼리에 있는 테이블 키를 서브쿼리 컬럼값의 테이블 키와 조인하는 방식을 많이 사용했다. 
    
- 연관 서브쿼리에 해당한다. 
    
  <br>
  <br>
  <br>  
    
✅ 집계함수를 써야하는데, 메인 select 절에 서브쿼리가 포함되어 있다면 ?

       : 조건으로 들어가는 메인테이블의 컬럼이 group by 항목으로 들어가야 한다. 


- 이것 때문에 에러를 본 적이 있다. 서브쿼리를 통째로 넣어보기도 하고 서브쿼리에서 가져오는 컬럼을 넣어보기도 했는데, 
    위에서 말했다시피 메인쿼리는 서브쿼리 컬럼을 사용할 수 없어서 에러가 나기는 매한가지였다. 
    
- 연관 서브쿼리 조건으로 들어간 메인쿼리 컬럼이 group by로 들어가니 해결되었다. 


<br><br><br>  

<h4>💡 comment</h4>
- 서브쿼리를 자주 사용하긴 했지만 항상 신중하게 사용해야 했다. 특히 스칼라 서브쿼리의 경우 '단일 행 오류'를 정말 많이 만났다. <br>
기준이 되는 키값 하나에 엮인 컬럼값이 두 개 이상인 경우 나는 오류였다. 

- 이런 상황에서는 기준 키값인 고객번호 하나만 서브쿼리에 사용한 select 절에 넣어 조회해보고, 어떤 컬럼 때문에 값이 두개 나오게 됐는지를 파악했다. 데이터 특성 상 주 원인은 날짜나 접수번호 같은 것들이었고 요청자료 기준에 맞는 조건을 서브쿼리에 추가해주면 행 하나만 나오게 수정할 수 있었다. 

- 애매하거나 랜덤으로 뽑아도 되는 조건의 경우 조건을 따로 추가하지 않고, 스칼라 서브쿼리 컬럼값에 MAX나 MIN 함수를 걸어 행이 하나만 나오도록 조치했다. 

- 단일 행 오류의 원인이 날짜인 경우는 가장 최근 값을 가져오도록 하거나, 쿼리 기준 날짜에 맞춰지도록 조건을 추가하면 해결할 수 있었다. 하지만 접수번호와 같이 날짜보다는 모호한 값인 경우 요청자와 협의가 필요했다. 접수이력을 다 보고싶다고 하면 해당 값은 서브쿼리를 쓰지 않고 직접 조인해서 키값 당 모든 접수번호가 보이도록 수정했고, 최근 값 하나만 있어도 된다고 하는 경우 MAX를 걸어 해결할 수 있었다. 

- 일부만 예시를 들긴 했지만 이런 조건 하나하나마다 요청자별로, 각 쿼리별로 항상 원하는 값이 달라졌기 때문에 항상 테이블을 파고들어 확인하는 과정이 필요했다.



  <br> <br>

*참고사이트
- https://kjh-alltag.tistory.com/53   







<br><br><br><br>
 <h3>📌 아우터 조인 </h3> <br>
 ✔ 대상 고객번호를 요청자쪽에서 미리 주거나, 조건을 정해주면 대상을 추려서 추출할 일이 많았다. 기준조건이 있으니 임시테이블을 생성해 이를 기준으로 아우터 조인을 걸어서 원하는 값을 가져오는 방식을 자주 사용하게 됐다.<br><br>
 
 ✅ Outer Join (외부조인)
 - 조인조건을 만족하지 못하는 행들을 보기 위해 사용된다. 기준 테이블의 컬럼값들을 누락 없이 모두 보여준다. 
  
  <br><br>
  
  
 ✅ 오라클에서의 조인 
        : (+) 기호 사용
- 두 테이블 사이에서 교집합이 아닌, 즉 조인조건을 만족하지 않는 행까지 값을 가져올 수 있다. (+)기호를 걸지 않은 쪽 테이블이 기준 테이블이 된다. 
- WHERE A.ID = B.ID (+) 와 같은 조인조건이 걸려있는 경우, A테이블의 모든 ID가 출력되고, B테이블은 A테이블 조인조건(ID)를 만족하는 경우 값이 출력되고, 만족하지 않으면 NULL이 출력된다. 

  <br><br>

 ✅ where절에 집합함수 있을 때 (+) 연산자 걸기 
 - a테이블 기준으로 b테이블을 아우터 조인하려고 할 때, WHERE NVL(A.DATA,0) = NVL(B.DATA,0) 라는 조건이 포함되어 있는 경우 연산자 거는 방식이 달랐다. 
 -  WHERE NVL(A.DATA,0) = NVL(B.DATA,0) (+)   --> 에러 발생
 -  WHERE NVL(A.DATA,0) = NVL(B.DATA(+),0)    --> 정상 작동, 함수를 사용할 경우 연산자는 함수 내 컬럼값 옆에 붙여야 한다.


  <br> <br>


<h4>💡 comment</h4>

- 아우터는 항상 헷갈리는 부분이었다. 추출 항목이 많았으므로 어떤 테이블을 기준으로 해야할지도 결정해야 했고, 테이블 갯수가 많은 경우 조건에 따라 일부만 아우터를 걸어야 하는 경우도 있어서 이러한 부분을 두고 동료와 많이 논의했었다. 
- 주로 LEFT 조인만 사용했고, 익숙해지지 않았을 당시에는 이론적인 내용을 알고있었는데도 (+) 연산자 거는 방향이 헷갈려서 다시 검색해보곤 했다. 
- 오라클에서만 (+)를 쓸 수 있다고 해서, 잊어버리지 않으려고 종종 LEFT JOIN ON 구문을 직접 써서 조인하는 방법도 사용했다. 


*참고사이트
- https://m.blog.naver.com/yysvip/220132590942
- https://titanic1997.tistory.com/50
    
    
    
    





    
